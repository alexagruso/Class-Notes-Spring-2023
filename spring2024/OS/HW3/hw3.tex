\documentclass[12pt]{article}
\pagenumbering{gobble}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage[headheight=0.25in,margin=1in]{geometry}
\usepackage{makecell}

\usepackage{tikz}
\usetikzlibrary{math}

\tikzstyle{deadline}=[
        draw=red,
        very thick
]

\tikzstyle{running}=[
        fill=blue!25!white
]

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\newcommand{\parens}[1]{\ensuremath{
    \left( #1 \right)
}}

\newcommand{\brackets}[1]{\ensuremath{
    \left[ #1 \right]
}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}

\newcommand{\solution}{\textbf{Solution:}}
\newcommand{\proof}{\textbf{Proof:}}
\newcommand{\done}{\ensuremath{
    \strut\hfill\blacksquare
}}

\linespread{1.25}

\begin{document}
    \pagestyle{fancy}

    \fancyhead[L]{Operating Systems}
    \fancyhead[C]{Assignment 3}
    \fancyhead[R]{Alex Agruso}

    \begin{itemize}
        \item [1.)] \begin{itemize}
            \item [a.)] Consider the following sequence of events.

                \verb|Inc(): read tally to register (reads 0)|

                \verb|Dec(): read tally to register (reads 0)|

                \verb|Dec(): perform decrement loop|

                \verb|Dec(): write tally (writes -50)|

                \verb|Inc(): perform increment loop (tally register reads 0)|

                \verb|Inc(): write tally (writes 50)|

                This order of execution saves each increment, but overwrites
                each decrement since the threads don't affect eachother's
                registers, thus the maximum value for tally is 50.
                A similar argument shows that the minimum value for tally is
                -50.

            \item [b.)] Suppose the two threads run exactly like the previous
                sequence, except each \verb|Dec()| is replaced with the
                second \verb|Inc()|.
                In this case, each increment performed by the second
                \verb|Inc()| would be overwritten by the first thread, and thus
                the minimum value for tally is 50.
                If there is no interference between the threads, then each
                increment would be counted for each thread, and thus the
                maximum value for tally is 100.
        \end{itemize}

        \item [2.)] Let \( S \) be a semaphore with a value of 1 and let
            \( P_1 \) and \( P_2 \) be processes.
            If \verb|wait()| was non-atomic, then the following could happen:

            \verb|P1 reads a value of 1 from S|

            \verb|P2 reads a value of 1 from S|

            \verb|P1 modifies S and enters the critical section|

            \verb|P2 modifies S and enters the critical section|

            After this program runs, both \( P_1 \) and \( P_2 \) will be in
            the critical section simultaneously, thus violating mutual
            exclusion.

        \pagebreak
        \item [3.)] The following psuedocode can be used to synchronize the mechanics:

            Mechanic 1:

            \verb|while true:|

            \verb|  wait(A)|

            \verb|  wait(B)|

            \verb|  wait(C)|

            \verb|  fix()|

            \verb|  signal(A,B,C) (shorthand for signal(A); signal(B); signal(C))|

            \verb|  take_break()|
            
            Mechanic 2:

            \verb|while true:|

            \verb|  wait(A)|

            \verb|  wait(C)|

            \verb|  fix()|

            \verb|  signal(A,C)|

            \verb|  take_break()|

            Mechanic 3:

            \verb|while true:|

            \verb|  wait(B)|

            \verb|  wait(C)|

            \verb|  fix()|

            \verb|  signal(B,C)|

            \verb|  take_break()|

            Assuming wait operations must be performed sequentially as written,
            it is impossible for this program to deadlock because it is 
            impossible for any of the mechanics to claim resource \( C \) and
            not finish their repair, thus no mechanic can claim \( C \)
            and then get stuck waiting for another resource.

        \pagebreak
        \item [4.)] \begin{itemize}
            \item [a.)] Adding both the available and taken resources, we find
                that the total number of available resources is 6, 7, 12, and 12
                for \( R_1 \), \( R_2 \), \( R_3 \), and \( R_4 \) respectively.

            \item [b.)] The remaining needs of the processes are given in the table:
                \begin{center}
                    \begin{tabular}{c|c|c|c|c}
                        & R_1 & R_2 & R_3 & R_4 \\
                        \hline
                        P_1 & 0 & 0 & 0 & 0 \\
                        P_2 & 0 & 7 & 5 & 0 \\
                        P_3 & 6 & 6 & 2 & 2 \\
                        P_4 & 2 & 0 & 0 & 2 \\
                        P_5 & 0 & 3 & 2 & 0 \\
                    \end{tabular}
                \end{center}

            \item [c.)] The system is in a safe state because the execution order
                \( \{ P_1,P_4,P_5,P_2,P_3 \} \) successfully runs each process.

            \item [d.)] As previously mentioned, the system is in a safe state, and thus
                the system is not deadlocked.

            \item [e.)] There is a high potential for processes 2 and 3 to become deadlocked
                with eachother. Since their collective demand for resources 1 and 2 are
                greater than the total available, it is possible to allocate resources in
                such a way that a deadlock occurs.

            \item [f.)] After the new request, \( P_3 \) would need 7 units of \( R_2 \).
                Performing the execution order from (c.), we would be left with \( P_3 \)
                as the last process, in which case there are clearly enough resources for
                it to run.
                However, if the request was granted immediately, then the system would
                deadlock, as after you execute \( P_1, P_4, \) and \( P_5 \), the system
                would only have 6 units of \( R_2 \) left instead of 7, and thus neither
                \( P_2 \) nor \( P_3 \) would be able to run next, thus causing a
                deadlock.
        \end{itemize}

        \pagebreak
        \item [5.)] Each philosopher is a separate instance of the following
            program:

            \verb|while true:|

            \verb|  wait(CHOPSTICKS[position], CHOPSTICKS[position + 1 modulo 5])|

            \verb|  eat_rice()|

            \verb|  signal(CHOPSTICKS[position], CHOPSTICKS[position + 1 modulo 5])|

            \verb|  sleep()|
            
            Since each philosopher is forced to wait for both chopsticks to
            be ready, it is impossible for a philosopher to pick up only a
            single chopstick then get stuck waiting, thus preventing deadlocks.
            One potential downside to this solution is that a philosopher
            might, by chance, have to spend more time waiting for the
            chopsticks than if they were allowed to pick up one chopstick
            at a time.

        \item [6.)] \begin{itemize}
            \item [a.)] The minimum value for \( M \) is 7, each process can
                claim up to 2 resources without completing, but as soon as
                any of them claim a third, it runs and subsequently frees
                the resources, preventing a deadlock.

            \item [b.)] Let \( T \) be the total needs of the processes, and
                suppose each process claims one less than its need, then the
                total number of claimed resources \( C \) would be given by
                \( C = T - N < M + N - N = M \), thus \( C + N < M \), thus
                we know that in this state there is still at least one
                available resource.
                However, since each process only requires one more resource,
                any process that claims the remaining resource will run and
                subsequently free its resources, thus a deadlock cannot occur.
        \end{itemize}
    \end{itemize}

\end{document}
